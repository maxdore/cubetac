\documentclass[11pt]{article}

\usepackage{hyperref}
\def\exampleautorefname{Example}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem*{expcont}{Example \continuation}
\newcommand{\continuation}{??}
\newenvironment{examplecontd}[1]
{\renewcommand{\continuation}{\ref{#1}}\expcont[continued]}
{\endexpcont}
\usepackage{algorithm}
\usepackage[noEnd=True, indLines=True]{algpseudocodex}
\algrenewcommand\algorithmicrequire{\textbf{Input:}}
\algrenewcommand\algorithmicensure{\textbf{Output:}}


\newcommand{\mdef}{:=}
\newcommand{\mname}[1]{\textit{{#1}}}
\newcommand{\problem}[1]{\textsc{{#1}}}

\newcommand{\join}{\wedge}
\newcommand{\meet}{\vee}
\newcommand{\dedekind}{\square_{\join \meet}}
% \newcommand{\pint}{[1]}
\newcommand{\pint}[1]{\mathbf{1}^{#1}}
\newcommand{\restrict}[2]{{#1}|_{#2}}
\newcommand{\psh}[1]{\mathbf{Set}^{{#1}^{op}}}
\renewcommand{\hom}[2]{\text{Hom}({#1} , {#2})}
\renewcommand{\dim}[1]{\mathsf{dim}({#1})}
\newcommand{\ctxtdim}[1]{|{#1}|}
\newcommand{\smap}[1]{s_{{#1}}}
\newcommand{\dmap}[2]{d_{({#1} , {#2})}}
\renewcommand{\deg}[1]{\lambda {#1}} % TODO OR JUST USE smap EVERYWHERE?

\newcommand{\pow}[1]{\mathcal{P}({#1})}
\newcommand{\cset}[1]{\mathsf{{#1}}}
\newcommand{\boundary}[1]{\partial({#1})}

\newcommand{\substtwo}[2]{\tiny
  \arraycolsep=.4pt\def\arraystretch{1}
  \begin{array}{ll}
    0 &\mapsto {#1} \\
    1 &\mapsto {#2}
  \end{array}
}
\newcommand{\constzero}{\substtwo{()}{()}}

\newcommand{\substfour}[4]{\tiny
  \arraycolsep=.4pt\def\arraystretch{1}
  \begin{array}{ll}
    00 &\mapsto {#1} \\
    01 &\mapsto {#2} \\
    10 &\mapsto {#3} \\
    11 &\mapsto {#4} 
  \end{array}
}


\title{ Searching in cubes}
\author{ Maximilian Dor\'e}
\date{\today}


\begin{document}
\maketitle	

As observed by \cite{orton17_axiom_model_cubic_type_theor_topos}, do not require
a full De Morgan structure. In particular, it suffices to consider only $\meet$
and $\join$ forming a bounded free distributive lattice.

\cite{williamson12_combin_homot_theor}: we shall think geometrically, and prove
algebraically!


\section{Cubical sets and their boundaries}

\subsection{The object/universe of study}

The Dedekind cube category $\dedekind$ is the full subcategory of the category
of posets and monotone maps with objects $\pint{n}$ for $n \geq 0$, where $\pint{}
= \{ 0<1 \}$. Therefore morphisms in $\dedekind$ are of
the form $\pint{m} \to \pint{n}$. The cardinality of $\hom{\pint{m}}{\pint{}}$ is the
$m$-th Dedekind number, which explains the name of $\dedekind$.

We denote elements of $\pint{n}$ with $(e_1 \ldots e_n)$ where $e_i \in \{0,1\}$
for $1 \leq i \leq n$ (we sometimes may omit the brackets). For an element $x =
(e_1 \ldots e_n)$ write $x_i \mdef e_i$. The poset $\pint{0}$ has one element
$()$.

Certain poset maps of interest are:
\begin{align*}
  s^i &: \pint{n} \to \pint{n-1}, (e_1 \ldots e_n) \mapsto (e_1 \ldots e_{i-1} e_{i+1} \ldots e_n) \text{ for } 1 \leq i \leq n\\
  d^{(i,e)} &: \pint{n-1} \to \pint{n}, 
      (e_1 \ldots e_{n-1}) \mapsto (e_1 \ldots e_{i-1} e e_{i+1} \ldots e_{n-1}) \text{ for } 1 \leq i \leq n, e \in \{0,1\}
\end{align*}


Cubical sets are objects of $\psh{\dedekind}$, i.e., presheaves over the
Dedekind cube category. For a cubical set $X$ write $X_n \mdef X(\pint{n})$,
which are called the $n$-cells of $X$. Given an element $p$ of $X_n$, we call
$\dim{p} \mdef n$ the dimension of $p$. Write also $\smap{i} \mdef X(s^i) : X_{n-1}
\to X_n$ and $\dmap{i}{e} \mdef X(d^{(i,e)}) : X_n \to X_{n-1}$, these maps are
called \mname{degeneracy maps} and \mname{face maps}, respectively. Note that in any non-empty
cubical set $X$, we must have non-empty $X_n$ for all $n$: given an $n$-cell
$p$, the codomain $X_{n+1}$ of $\smap{n+1}$ as well as the codomain $X_{n-1}$ of
$\dmap{n}{\_}$ must be non-empty. The objects in the image of some $\smap{i}$ are
called \mname{degeneracies}. If the dimension $n$ is understood, we will sometimes
denote with $\smap{m}$ the composite $\smap{m} \circ \smap{m-1} \circ \ldots
\circ \smap{n+1}$. This gives the shorthand $\smap{m}(p)$ for an $n$-cell
considered to be a degenerate $m$-cell.

\begin{example}\label{exp:int}
  The cubical set $\cset{Int}$ is generated by the following data: $\cset{Int}_0
  = \{ \cset{zero} , \cset{one} \}$ and $\cset{seg} \in \cset{Int}_1$ with
  $\dmap{1}{0}(\cset{seg}) = \cset{zero}$ and $\dmap{1}{1}(\cset{seg}) =
  \cset{one}$. We have degenerate cells in higher dimensions for the $\smap{i}$
  to have a codomain, for instance, $\smap{1}(\cset{zero})$ is a degenerate
  1-cell which is constantly $\cset{zero}$, captured by the fact that the face
  maps $\dmap{1}{\_}$ send
  $\smap{1}(\cset{zero})$ back to $\cset{zero}$.
\end{example}

\begin{example}\label{exp:loopspace}
  We define the cubical set $\cset{2Loop}$ with the following data: We have a
  single 0-cell, so $\cset{2Loop}_0 = \{
  \cset{a} \}$. There is one non-degenerate 2-cell $\cset{\alpha} \in
  \cset{2Loop}_2$, which has as its faces $\cset{a}$ as a degenerate 1-cell, i.e.,
  $\dmap{2}{0}(\cset{\alpha}) = \dmap{2}{1}(\cset{\alpha}) =
  \dmap{1}{0}(\cset{\alpha}) = \dmap{1}{1}(\cset{\alpha}) = \smap{1} (\cset{a})$.
\end{example}

\begin{example}\label{exp:torus}
  We define the cubical set $\cset{Torus}$ with the following data: We have a
  single 0-cell, so $\cset{Torus}_0 = \{ \cset{a} \}$. There are two
  non-degenerate 1-cells $\cset{p}$ and $\cset{q}$ and one non-degenerate 2-cell
  $\dmap{2}{0}(\cset{\alpha}) = \dmap{2}{1}(\cset{\alpha}) = p$ and
  $\dmap{1}{0}(\cset{\alpha}) = \dmap{1}{1}(\cset{\alpha}) = q$.
\end{example}

\begin{example}\label{exp:triangle}
  We define the cubical set $\cset{Triangle}$ as generated by the following
  data: The 0-cells are $\cset{Triangle}_0 = \{ \cset{x} , \cset{y} , \cset{z}
  \}$. The non-degenerate 1-cells are $\{ \cset{p} ,
  \cset{q} , \cset{r} \} \subseteq \cset{Triangle}_1$ on which the face maps are defined by
    $\dmap{1}{0}(\cset{p}) = \cset{x}$ and $\dmap{1}{1}(\cset{p}) = \cset{y}$,
    $\dmap{1}{0}(\cset{q}) = \cset{y}$ and $\dmap{1}{1}(\cset{q}) = \cset{z}$,
    $\dmap{1}{0}(\cset{r}) = \cset{x}$ and $\dmap{1}{1}(\cset{r}) = \cset{z}$.
    We have one non-degenerate 2-cell $\cset{\phi} \in \cset{Triangle}_2$ with $\dmap{1}{0}(\cset{\phi}) =
    \cset{p}$, $\dmap{1}{1}(\cset{\phi}) = \cset{r}$, $\dmap{2}{0}(\cset{\phi})
    = \smap{1}(\cset{x})$ and $\dmap{2}{1}(\cset{\phi}) = \cset{q}$.
\end{example}

\begin{example}{\label{exp:assoc}}
  Associativity of three paths
\end{example}

\begin{example}\label{exp:group}
  % Given a set of generators $\{a, ...\}$ of a group $G$, define $\cset{Group}$
  % with a single 0-cell $\cset{Group}_0 = \{ \cset{\star} \}$, 
  % 1-cells $\{\cset{a} , \cset{a^{-1}} ... \} \subseteq \cset{Group}_1$ and a
  % 2-cell $\cset{idem_a}$ for any generator $a$ with 
  % $\dmap{2}{0}(\cset{idem_a}) = \cset{a}$, $\dmap{1}{1}(\cset{idem_a}) =
  % \cset{a^{-1}}$ and $\dmap{2}{1}(\cset{idem_a}) = \dmap{1}{0}(\cset{idem_a}) = \smap{1} (\cset{\star})$.

  Given a set of generators $\{a, ...\}$ of a group $G$, define $\cset{Group}$
  with a single 0-cell $\cset{Group}_0 = \{ \cset{\star} \}$, 
  1-cells $\{\cset{a} , ... \} \subseteq \cset{Group}_1$ 
  
  (there are more 2-cells that need to be added as explained in \cite[Sect. 6.3]{bezem14_model_type_theor_cubic_sets})
  % Note that this is not a set. Doesn't matter for undecidability proof?
\end{example}


When is a cubical set a \emph{type}, i.e., captures heterogenous identifications
of elements in a type?

Hope for syntax-free criterion.

TODO Uniform Kan condition


(still some issues: definitional equivalence of identity elimination has not
been verified by model, only holds up to higher identification)
A type is a cubical set satisfying the uniform Kan condition.

\subsection{Distortions and contexts} % OUR NEW NOTIONS

These examples suggest that we only require a bit of generating data from which
the other cells and maps can be inferred in a unique way. This is what the next
section is for.

We want to specify what a collection of face maps does???

In general, 
If we have an $n$-cell $p$, we can turn it into an $m$-cell with a map $\sigma :
\pint{m} \to \pint{n}$: TODO GEOMETRIC INTUITION

This gives many cells, complex to describe (this is what is what the boundary
below is for)

We will call the morphisms of $\dedekind$ maps substitutions.

TODO GIVE THIS IS A NAME -- NOT DEGENERACY, BUT MORE GENERAL. MAYBE contortion?
OR substitution? Or substitution gives rise to contortion?
OR deformation?

TODO EXAMPLE

TODO NOTATION $\constzero$ 

We will call poset maps substitutions in the following (they use interval
substitutions in the syntactic characterisation).



The examples suggests that we need a more concise notation to describe cubical
sets. We only give the generating cells and their boundaries, which leads to the
notion of higher inductive types in Cubical Agda.

In a cubical set $X$, the boundary of an $n$-cell $p$, called $\partial p$, is
the union of the images of the maps $\dmap{i}{e} : X_n \to X_{n-1}$, which are
$2 \cdot n$ many $(n-1)$-cells. Conversely, we can specify a cubical set by
declaring each cell with their boundary. 


We will consider a fixed cubical set $X$ in the following.

\begin{definition}
  A \mname{term} $t$ is a tuple $(p, \sigma)$ where $\sigma : \pint{n} \to
  \pint{\dim{p}}$. We call $\dim{t} \mdef n$ the dimension of $t$.

  TODO OR IT IS COMPOSITION OF OPEN BOX
\end{definition}

For example, the degenerate 1-cell $\smap{1}(\cset{zero})$ from \autoref{exp:int}
is represented in our setting by the term $(\cset{zero}, \constzero)$.

\begin{definition}
  A \mname{boundary} $T$ is a list of tuples $[(t_1,s_1) , \ldots , (t_n,s_n)]$
  where each $t_\_$, $s_\_$ is a term of dimension $n-1$. We call $\dim{T} \mdef n$ the dimension of $T$.
\end{definition}

\begin{definition}
  A \mname{context} $\Gamma$ is a list of declarations $[ (p_1,T_1) , \ldots , (p_k,T_k)]$
  where each $p_\_$ is a term and each $T_\_$ is a boundary. We call
  $\ctxtdim{\Gamma} \mdef k$ the length of the context.
\end{definition}

A cubical set is said to be generated by a context if TODO HOW EXACTLY

In \cite[Sect. 6.4]{bezem14_model_type_theor_cubic_sets}, strict groupoid turned into
cubical set with general construction

TODO WELL-FORMEDNESS OF CUBICAL SET DESCRIPTION

Higher inductive types are constructed as generalized pushout construction (free
$\omega$-groupoid construction)

\begin{examplecontd}{exp:int}
  The following context generates $\cset{Int}$: TODO
\end{examplecontd}

\begin{examplecontd}{exp:loopspace}
  The following context generates $\cset{2Loop}$:

  $[ (\cset{a},[]) , (\cset{\alpha} , [ ((a, \constzero) , (a, \constzero)) ,
  ((a, \constzero), (a, \constzero)) ])]$
  
\end{examplecontd}

\begin{examplecontd}{exp:triangle}
  The following context generates $\cset{Triangle}$: TODO 
\end{examplecontd}


We will only consider certain boundaries. More general boundary problem is
conceivable, for now we limit ourselves to the following:

We have $\partial ((\smap{2} \circ \smap{1}) \cset{a}) = \partial{\cset{\alpha}}$.


Allowable boundary shapes are generating cofibrations from a model categorical perspective


We have to consider sets of elements $xs$ of $\pint{m}$ which pick out a face of
a cube. For instance, $\{00,01\}$ picks out the first(?) line in a square.

\begin{algorithm}[H]
  \caption{Computing the boundary of a term with substitution}\label{alg:boundary}
  \begin{algorithmic}
    \Require $(p, \sigma)$ where $p$ is an $n$-cell of $X$ and $\sigma : \pint{m} \to \pint{n}$.
    \Ensure $[faces , ... , ]$
    
    \Procedure{Boundary}{$p, \sigma$}
    \State Do Something
    % let (i , Endpoint e) = getFirstCommon xs in
    % let (a , b) = fgs !! (i - 1) in
    % let (Term f subst) = if e then b else a in
    % evalFace cube f (map (\x -> subst ! removeInd x i) xs)
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

For instance, in \autoref{exp:loopspace} the term
$(\phi,\substfour{00}{00}{01}{01})$ picks out the first face of $\phi$ and
is judgmentally (?) equal to $(p,\substfour{0}{0}{1}{1})$ TODO REALLY

\begin{algorithm}[H]
  \caption{Normalize a substituted term to normal form}\label{alg:normalize}
  \begin{algorithmic}
    \Require $(p, vs)$ where $p$ is an $n$-cell of $X$/$Gamma$ and $vs$ multiset
    of $\pint{n}$
    \Ensure $(f, \sigma)$ normalized term if face of original term
    
    \Procedure{Normalize}{$p, vs$}
    \If{$vs$ is sub face}
    \State Do Something
    \Else{}
    \State $\sigma : \pint{n} \to \pint{n}, \sigma(x) \to vs !! i$
    \State \Return{$(p, \sigma)$}
    \EndIf
    \EndProcedure

    % let ty = lookupDef cube f in
    % case dim ty of
    % 0 -> Term f (constSubst (log2 (length vs)))
    % n -> if any (\u -> head vs `vdiff` u > n-1) (tail vs)
    % then Term f (reconstrPMap vs)
    % else evalBoundary cube ty vs
  \end{algorithmic}
\end{algorithm}

TODO RUNTIME








\begin{algorithm}[H]
  \caption{Well-formed boundary}\label{alg:wellformedboundary}
  \begin{algorithmic}
    \Require $\Gamma$ context, $T$ term
    \Ensure \texttt{OK} if $T$ well formed, \texttt{Error} otherwise

    \Procedure{WellFormed}{$\Gamma, T$}
    \State Do Something
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{Well-formed context}\label{alg:wellformedcontext}
  \begin{algorithmic}
    \Require $\Gamma$ context
    \Ensure \texttt{OK} if $\Gamma$ well formed, \texttt{Error} otherwise

    \Procedure{WellFormed}{$\Gamma$}
    \State Gradually build up? Or is it ok to have mutually defined cells?
    \EndProcedure
  \end{algorithmic}
\end{algorithm}


\begin{algorithm}[H]
  \caption{Faces}\label{alg:wellformedcontext}
  \begin{algorithmic}
    \Require $m$, $n$
    \Ensure $\{ xs \}$ where $xs$ are the $n$-faces of $\pint{m}$

    \Procedure{Faces}{$m,n$}
    \If{$n = 0$}
    \State $\{ \{ x \} \mid x \in \pint{m} \}$
    \ElsIf{$m = n$}
    \State $\{ \pint{m} \}$
    \Else
    \State $\{ \{ 0x \mid x \in xs \} , \{ 1x \mid x \in xs\} \mid xs \in $ \Call{Faces}{$m-1,n$} $ \}$
    \Statex $\cup TODO$
    \EndIf
    \EndProcedure
    
    % getFaces :: Int -> Int -> [[Vert]]
    % getFaces m 0 = map (: []) (createPoset m)
    % getFaces m n | m == n = [ createPoset m ]
    % getFaces m n =
    % map (map (e0 `insv`)) (getFaces (m-1) n)
    % ++ map (map (e1 `insv`)) (getFaces (m-1) n)
    % ++ map (\l -> map (e0 `insv`) l ++ map (e1 `insv`) l) (getFaces (m-1) (n-1))
  \end{algorithmic}
\end{algorithm}


\section{Searching for cells}

In a cubical set, we have very many distortions (?) lying around. Searching
these is complicated. Here we present first approach to this.

The search problem is the following:

\begin{definition}
  Given a cubical set $X$ (given by a context $\Gamma$) and a boundary $T$ (TODO over $X$?), the problem
  \problem{CubicalCell}($X$,$T$) is to find a term $t$ such that $\boundary{t} = T$.
\end{definition}

In general, \problem{CubicalCell} is undecidable.

If it can be solved by a distortion, it is clearly decidable since there are
only finitely many substitutions for each cell in the context, and the search
space is thereby finite. However, the search space grows super-exponentially:
Suppose we want to check if there is an $m$-dimensional contortion of a 1-cell
satisfying a goal, i.e., we are looking for a monotone map $\pint{m} \to
\pint{}$,. For $m = 6$, there are $7828354$ substitutions that we would have to
check and for 9 the exact number of possible substitutions has not even been
computed yet \url{http://oeis.org/A00372}. Therefore we need something more
clever to explore the search space.


\subsection{Potential substitutions}

For an effective algorithm, we turn to following notion.

We introduce potential substitution, which keep track of all the potential
values of $\pint{n}$ a poset map $\sigma$ might assign to an element of $x \in \pint{m}$.

They allow to represent all maps $\pint{m} \to \pint{n}$ at once.
Solves memory problem. We need to explore the search space cleverly.

\begin{definition}
  A \mname{potential poset map} (\mname{ppm}) is a map $\Sigma : \pint{m} \to \pow{\pint{n}}$
  such that for all $x \leq y$ : for all $u \in \Sigma(x)$ exists $v \in
  \Sigma(y)$ such that $u \leq v$.
\end{definition}

The condition on poset maps means that 


For effectively computing with poset maps we will consider their graphs. We also
list the vertices such that if $x \leq y$ then $x$ is earlier than $y$ in the
list. This allows us to traverse through the graph and know that if an element
$x$ is at a certain position in the list, all elements below $x$ will be seen at
a certain point.

A non-empty potential map is one which has a non-empty set of possible values
for any element, which can be checked in $2^m$ steps. Given a poset $xs
\subseteq \pint{m}$, we can restrict a ppm $\Sigma : \pint{m} \to \pow{\pint{n}}$ to a
new ppm $\restrict{\Sigma}{xs} : xs \to \pow{\pint{n}}$ just like any function.

\begin{algorithm}[H]
  \caption{Update potential substitution}\label{alg:simple}
  \begin{algorithmic}
    \Require $\Sigma : \pint{m} \to \pow{\pint{n}}$ ppm, $x \in
    \pint{m}$, $vs \in \pow{\pint{n}} - \emptyset$
    \Ensure Updated ppm $\Sigma' : \pint{m} \to \pint{n}$ with $\Sigma(x) = vs$.

    \Procedure{UpdatePPM}{$\Sigma, (x,vs)$}
    \For{$y \gets \pint{m}$}
    \If{$x = y$}
    \State $\Sigma'(x) \gets vs$
    \ElsIf{$y \leq x$}
    \State $\Sigma'(y) \gets \{ u \mid u \in \Sigma(y) \text{ such that } \exists
    v \in vs : u \leq v \} $
    \ElsIf{$x \leq y$}
    \State $\Sigma'(y) \gets \{ u \mid u \in \Sigma(y) \text{ such that } \exists
    v \in vs : v \leq u \} $
    \EndIf
    \EndFor
    \State \Return{$\Sigma'$}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

Therefore we have a runtime of $\mathcal{O}(2^m 2^n)$

From a potential poset map we can generate all poset maps. This has a worst-case
runtime of Dedekind for the full one.


\begin{algorithm}[H]
  \caption{Potential substitution to substitutions}\label{alg:simple}
  \begin{algorithmic}
    \Require $\Sigma : \pint{m} \to \pow{\pint{n}}$ potential poset map
    \Ensure $\{ \sigma : \pint{m} \to \pint{n} \}$ poset maps
    
    \Procedure{UnfoldPPM}{$\Sigma$}
    \State $\sigma : x \mapsto \Sigma(x) $
    TODO
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

$\mathcal{O}(D_m^n)$

For an efficient algorithm we instead consider an algorithm which extracts the
first substitution from a potential substitution.

\begin{algorithm}[H]
  \caption{Potential substitution to substitution}\label{alg:simple}
  \begin{algorithmic}
    \Require $\Sigma : \pint{m} \to \pow{\pint{n}}$ non-empty ppm
    \Ensure $\sigma : \pint{m} \to \pint{n}$ poset map

    \Procedure{FstPPM}{$\Sigma$}
    \For{$x \gets \pint{m}$}
    \State $v \gets \mathsf{first}(\Sigma(x))$
    \State $\sigma \gets \Call{FstPPM}{\restrict{\Sigma}{-x}}$
    \State $\sigma(x) \mapsto v$
    \EndFor
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

This has amortised runtime of $\mathcal{O}(2^m 2^n)$.

\subsection{Simple solver}

We want to try and see 

\begin{algorithm}[H]
  \caption{Simple solver}\label{alg:simple}
  \begin{algorithmic}
    \Require $\Gamma$ context, $(p,S) \in \Gamma$, $T$ goal boundary
    \Ensure $\sigma$ s.t. $\boundary{p,\sigma} = T$ if there is such a
    $\sigma$, \texttt{Unsolvable} otherwise

    \Procedure{SimpleSolve}{$\Gamma, T$}
    \State $m = \dim{T} , n = \dim{S} $
    \State $\Sigma \gets \{ x \mapsto \pint{n} \mid x \in \pint{m} \}$
    \For{$xs \gets (m-1)$-face} \Comment{$2 \cdot m$ such faces}
    \State $\sigma s \gets $ \Call{UnfoldPPM}{$\restrict{\Sigma}{xs}$} \Comment{$D_{m-1}^n$}
    \For{$x \gets xs$}
      \State \Call{UpdatePPM}{$\Sigma, x, \{ v \mid v \in \Sigma(x) : \exists
        \sigma \in \sigma s : \sigma(x) = v, $
      \Statex \hfill \Call{Normalize}{$p,img(\sigma)$} $ = {T}@ xs \}$}
    \EndFor
    \EndFor
    \If{$\exists x \in \pint{m} \text{ such that } \Sigma(x) = \emptyset$}
    \State \Return{\texttt{Unsolvable}}
    \Else
    \State $\sigma \gets$ \Call{FstSubst}{$\Sigma$}
    \State \Return{$(p , \sigma )$}
    \EndIf
    \EndProcedure

    % let psubst = foldr
    % (\xs sigma ->
    % let a = evalBoundary cube goal xs in
    % let gadgets = map (map snd . Map.toList) (getSubsts (sigma `restrictKeys` Set.fromList xs)) in
    % let gadgets' = filter (\g -> evalFace cube f g == a) gadgets in
    % let vus = map (\i -> nub (map (!!i) gadgets')) [0 .. length xs - 1] in
    % foldl (\s (x , vu) -> updatePSubst s x vu) sigma (zip xs vus)
    % )
    % (createPSubst (dim goal) (dim ty))
    % (getFaces (dim goal) (dim goal - 1)) in
  \end{algorithmic}
\end{algorithm}

Instead of $D_m^n$ runtime we have $2 m D_{m-1}^n$ runtime, which is a significant
improvement.

More than that, the potential substitutions allow us to narrow down the search
space in other ways.

Try to reduce the search space going from the bottom.

COMPLETENESS???

% \begin{algorithm}[H]
%   \caption{Simple solver}\label{alg:simple}
%   \begin{algorithmic}
%     \Require $\Gamma$ context, $T$ goal boundary
%     \Ensure $t \in DISTORTIONS (\Gamma)$ s.t. $\boundary{t} = T$ if there is such a $t$, \texttt{Unsolvable} otherwise

%     \Procedure{SimpleSolve}{$\Gamma, T$}
%     \For{$(p,S) \gets \Gamma$} 
%       \State $\Sigma \gets \{ x \mapsto \pint{\dim{S}} \mid x \in \pint{\dim{T}} \}$
%       \For{$t \gets T$} \Comment{consider T as set, remove tuples}
%         \For{$x \gets ???$} 
%           \State{$\Sigma(x) \gets \{ v \mid v \in \Sigma(x) \text{ such that } ... \}$}
%           \State update to ensure monotonicity
%           \If{$\Sigma(x) = \emptyset$}
%             \State{Continue with next $(p,S)$ / exit both for loops}
%           \EndIf
%         \EndFor
%         \EndFor
%       \State \Return{$(p, fst \Sigma)$}
%     \EndFor
%     \State \Return{\texttt{Unsolvable}}
%     \EndProcedure
%   \end{algorithmic}
% \end{algorithm}



We can try this for all elements in the context, thereby have run time
$\mathcal{O}( \ctxtdim{\Gamma} )$

\section{Composition solver}

We use Kan composition


\section{(Un)decidability}

Show how in general undecidable: Reduce to word problem

Find how decidable groups carry over to decidable problems?



\section{Negation}

How to encode search for reversals


\section{Connections}

Since the generating data is the non-degenerate cells and the face maps on them,
we can adopt the following notation to describe cubical sets, which go under
higher inductive types in Cubical Agda:

TODO also boundary description with poset maps. These correspond to specifying
the dmaps: One index is constant, rest is given by given poset map


\subsubsection{Relation to face formulas}

The morphisms in $\dedekind$ have a succinct description as tuples of elements of a free
distributive lattices, which we will call telescopes.
Cubical Agda uses telescopes to describe this. However, these are hard to
construct and have no geometric intuition. This is why we had used poset maps.
We can go back and forth between both representations easily.


Given $s : \pint{m} \to \pint{n}$, we compute an $n$-tuple of elements of the
free distributive lattice over $m$ elements as follows:

The $i$-th entry is $\{ x \in \pint{m} \mid s(x)_i = 1 \}$. An element $x$ can be
seen as a clause if we regard it as indicator of which elements of the lattice
are used, e.g., $(1,0,1)$ represents the clause $x \meet z$ if the three
elements of the lattice are $x$, $y$ and $z$.

\begin{algorithm}[H]
  \caption{TODO}\label{alg:subst2tele}
  \begin{algorithmic}
    \Require $\sigma : \pint{m} \to \pint{n}$
    \Ensure $\phi$ $n$-tuple of elements of free distributive lattice over $m$ variables

    \Procedure{Subst2Tele}{$\sigma$}
    \For{$i \gets 1$ to $n$} 
      \State $\phi_i \gets \{ x \in \pint{m} \mid \sigma(x)_i = 1 \}$
      \Comment{$\mathcal{O}(2^m)$ many elements in $\pint{m}$}
    \EndFor
    \State \Return{$(\phi_1, ... , \phi_n)$}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}

TODO mention set representation of DNF. Also mention normalization necessary --
what's its runtime?

From an $n$-tuple of formulas over $\phi$ we can read off a poset map $s :
\pint{m} \to \pint{n}$ as follows: Given an element $x \in \pint{m}$, $s(x) = (e_1
, ... , e_n) $ where $e_i = \phi_i @ x$ TODO EVALUATION

\begin{algorithm}[H]
  \caption{TODO}\label{alg:teletosubst}
  \begin{algorithmic}
    \Require TODO
    \Ensure TODO

    \Procedure{Tele2Subst}{$p$}
    \For{$x \gets \pint{m}$} 
      \For{$i \gets 1$ to $n$}
        \State $\sigma(x)_i \gets \phi_i @ x$
      \EndFor
    \EndFor
    \State \Return{$\sigma$}
    \EndProcedure
  \end{algorithmic}
\end{algorithm}


Therefore going back and forth between formulas and poset map takes
$\mathcal{O}(2^mn)$ many steps. This is linear in the number of elements of the
data structures we are considering, so pretty quick and no obstruction.

\begin{example}
  % EXAMPLE
  % [(000,00),(001,00),(010,00),(011,01),(100,10),(101,11),(110,10),(111,11)]
  % 1 ((2 /\ 3) \/ (1 /\ 3))
\end{example}

TODO PROOF THAT THESE ARE MUTUALLY INVERSE?


\subsection{Nominal perspective}

Have set $I = \{i , j, k , ...\}$ of names. Then give complete description for
Cubical Agda.

\end{document}